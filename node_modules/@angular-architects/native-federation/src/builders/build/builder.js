"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runBuilder = runBuilder;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs"));
const mrmime = tslib_1.__importStar(require("mrmime"));
const build_1 = require("@angular/build");
const private_1 = require("@angular/build/private");
const architect_1 = require("@angular-devkit/architect");
const options_1 = require("@angular-devkit/build-angular/src/builders/dev-server/options");
const build_2 = require("@softarc/native-federation/build");
const build_3 = require("@softarc/native-federation/build");
const angular_esbuild_adapter_1 = require("../../utils/angular-esbuild-adapter");
const build_4 = require("@softarc/native-federation/build");
const build_5 = require("@softarc/native-federation/build");
const build_6 = require("@softarc/native-federation/build");
const architect_2 = require("@angular-devkit/architect");
const dev_server_1 = require("../../utils/dev-server");
const rebuild_events_1 = require("../../utils/rebuild-events");
const updateIndexHtml_1 = require("../../utils/updateIndexHtml");
const fs_1 = require("fs");
const mem_resuts_1 = require("../../utils/mem-resuts");
const shared_mappings_plugin_1 = require("../../utils/shared-mappings-plugin");
function _buildApplication(options, context, pluginsOrExtensions) {
    let extensions;
    if (pluginsOrExtensions && Array.isArray(pluginsOrExtensions)) {
        extensions = {
            codePlugins: pluginsOrExtensions,
        };
    }
    else {
        extensions = pluginsOrExtensions;
    }
    return (0, private_1.buildApplicationInternal)(options, context, extensions);
}
function runBuilder(nfOptions, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* runBuilder_1() {
        var _a, e_1, _b, _c;
        let target = (0, architect_2.targetFromTargetString)(nfOptions.target);
        let _options = (yield tslib_1.__await(context.getTargetOptions(target)));
        let builder = yield tslib_1.__await(context.getBuilderNameForTarget(target));
        if (builder === '@angular-devkit/build-angular:browser-esbuild') {
            build_2.logger.info('.: NATIVE FEDERATION - UPDATE NEEDED :.');
            build_2.logger.info('');
            build_2.logger.info("Since version 17.1, Native Federation uses Angular's");
            build_2.logger.info('Application-Builder and its Dev-Server.');
            build_2.logger.info('');
            build_2.logger.info('If you are sill on Angular 17.0.x, please update to');
            build_2.logger.info('Angular 17.1.x or downgrade to Native Federation 17.0.x.');
            build_2.logger.info('');
            build_2.logger.info('For working with Native Federation 17.1.x (recommented), ');
            build_2.logger.info('please update your project config, e.g. in angular.json');
            build_2.logger.info('');
            build_2.logger.info('This command performs the needed update for default configs:');
            build_2.logger.info('');
            build_2.logger.info('\tng g @angular-architects/native-federation:appbuilder');
            build_2.logger.info('');
            build_2.logger.info('You need to run it once per application to migrate');
            build_2.logger.info('Please find more information here: https://shorturl.at/gADJW');
            return yield tslib_1.__await(void 0);
        }
        let options = (yield tslib_1.__await(context.validateOptions(_options, builder)));
        const outerOptions = options;
        const normOuterOptions = nfOptions.dev
            ? yield tslib_1.__await((0, options_1.normalizeOptions)(context, context.target.project, outerOptions))
            : null;
        const runServer = nfOptions.dev && nfOptions.devServer !== false;
        const write = true;
        const watch = nfOptions.watch;
        if (runServer) {
            target = (0, architect_2.targetFromTargetString)(outerOptions.buildTarget);
            _options = (yield tslib_1.__await(context.getTargetOptions(target)));
            builder = yield tslib_1.__await(context.getBuilderNameForTarget(target));
            options = (yield tslib_1.__await(context.validateOptions(_options, builder)));
        }
        options.watch = watch;
        if (nfOptions.baseHref) {
            options.baseHref = nfOptions.baseHref;
        }
        if (nfOptions.outputPath) {
            options.outputPath = nfOptions.outputPath;
        }
        const rebuildEvents = new rebuild_events_1.RebuildHubs();
        const adapter = (0, angular_esbuild_adapter_1.createAngularBuildAdapter)(options, context, rebuildEvents);
        (0, build_3.setBuildAdapter)(adapter);
        (0, build_2.setLogLevel)(options.verbose ? 'verbose' : 'info');
        const outputPath = options.outputPath;
        const outputOptions = Object.assign(Object.assign({ browser: 'browser', server: 'server', media: 'media' }, (typeof outputPath === 'string' ? undefined : outputPath)), { base: typeof outputPath === 'string' ? outputPath : outputPath.base });
        const browserOutputPath = path.join(outputOptions.base, outputOptions.browser);
        const fedOptions = {
            workspaceRoot: context.workspaceRoot,
            outputPath: browserOutputPath,
            federationConfig: infereConfigPath(options.tsConfig),
            tsConfig: options.tsConfig,
            verbose: options.verbose,
            watch: false, // options.watch,
            dev: !!nfOptions.dev,
        };
        const activateSsr = nfOptions.ssr && !nfOptions.dev;
        const config = yield tslib_1.__await((0, build_5.loadFederationConfig)(fedOptions));
        const externals = (0, build_4.getExternals)(config);
        const plugins = [
            (0, shared_mappings_plugin_1.createSharedMappingsPlugin)(config.sharedMappings),
            {
                name: 'externals',
                setup(build) {
                    if (!activateSsr && build.initialOptions.platform !== 'node') {
                        build.initialOptions.external = externals.filter((e) => e !== 'tslib');
                    }
                },
            },
        ];
        // SSR build fails when externals are provided via the plugin
        if (activateSsr) {
            options.externalDependencies = externals;
        }
        const middleware = [
            (req, res, next) => {
                const url = removeBaseHref(req, options.baseHref);
                const fileName = path.join(fedOptions.workspaceRoot, fedOptions.outputPath, url);
                const exists = fs.existsSync(fileName);
                if (url !== '/' && url !== '' && exists) {
                    const lookup = mrmime.lookup;
                    const mimeType = lookup(path.extname(fileName)) || 'text/javascript';
                    const rawBody = fs.readFileSync(fileName, 'utf-8');
                    const body = addDebugInformation(url, rawBody);
                    res.writeHead(200, {
                        'Content-Type': mimeType,
                        'Access-Control-Allow-Origin': '*',
                        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
                        'Access-Control-Allow-Headers': 'Content-Type',
                    });
                    res.end(body);
                }
                else {
                    next();
                }
            },
        ];
        const memResults = new mem_resuts_1.MemResults();
        let first = true;
        let lastResult;
        if ((0, fs_1.existsSync)(fedOptions.outputPath)) {
            (0, fs_1.rmSync)(fedOptions.outputPath, { recursive: true });
        }
        if (!(0, fs_1.existsSync)(fedOptions.outputPath)) {
            (0, fs_1.mkdirSync)(fedOptions.outputPath, { recursive: true });
        }
        if (!write) {
            (0, angular_esbuild_adapter_1.setMemResultHandler)((outFiles, outDir) => {
                const fullOutDir = outDir
                    ? path.join(fedOptions.workspaceRoot, outDir)
                    : null;
                memResults.add(outFiles.map((f) => new mem_resuts_1.EsBuildResult(f, fullOutDir)));
            });
        }
        try {
            yield tslib_1.__await((0, build_6.buildForFederation)(config, fedOptions, externals));
        }
        catch (e) {
            process.exit(1);
        }
        options.deleteOutputPath = false;
        const appBuilderName = '@angular-devkit/build-angular:application';
        const builderRun = runServer
            ? (0, private_1.serveWithVite)(normOuterOptions, appBuilderName, _buildApplication, context, nfOptions.skipHtmlTransform
                ? {}
                : { indexHtml: transformIndexHtml(nfOptions) }, {
                buildPlugins: plugins,
                middleware,
            })
            : (0, build_1.buildApplication)(options, context, {
                codePlugins: plugins,
            });
        try {
            // builderRun.output.subscribe(async (output) => {
            for (var _d = true, builderRun_1 = tslib_1.__asyncValues(builderRun), builderRun_1_1; builderRun_1_1 = yield tslib_1.__await(builderRun_1.next()), _a = builderRun_1_1.done, !_a; _d = true) {
                _c = builderRun_1_1.value;
                _d = false;
                const output = _c;
                lastResult = output;
                if (!output.success) {
                    (0, dev_server_1.setError)('Compilation Error');
                    (0, dev_server_1.reloadBrowser)();
                    continue;
                }
                else {
                    (0, dev_server_1.setError)(null);
                }
                if (!write && output.outputFiles) {
                    memResults.add(output.outputFiles.map((file) => new mem_resuts_1.EsBuildResult(file)));
                }
                if (!write && output.assetFiles) {
                    memResults.add(output.assetFiles.map((file) => new mem_resuts_1.NgCliAssetResult(file)));
                }
                if (write && !runServer && !nfOptions.skipHtmlTransform) {
                    (0, updateIndexHtml_1.updateIndexHtml)(fedOptions, nfOptions);
                }
                // if (!runServer) {
                //   yield output;
                // }
                if (!first && (nfOptions.dev || watch)) {
                    setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        try {
                            yield (0, build_6.buildForFederation)(config, fedOptions, externals);
                            build_2.logger.info('Done!');
                        }
                        catch (_a) {
                            build_2.logger.error('Not successful!');
                        }
                        // if (runServer) {
                        //   setTimeout(() => reloadShell(nfOptions.shell), 0);
                        // }
                    }), nfOptions.rebuildDelay);
                }
                first = false;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = builderRun_1.return)) yield tslib_1.__await(_b.call(builderRun_1));
            }
            finally { if (e_1) throw e_1.error; }
        }
        yield yield tslib_1.__await(lastResult || { success: false });
    });
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.default = (0, architect_1.createBuilder)(runBuilder);
function removeBaseHref(req, baseHref) {
    let url = req.url;
    if (baseHref && url.startsWith(baseHref)) {
        url = url.substr(baseHref.length);
    }
    return url;
}
function infereConfigPath(tsConfig) {
    const relProjectPath = path.dirname(tsConfig);
    const relConfigPath = path.join(relProjectPath, 'federation.config.js');
    return relConfigPath;
}
function transformIndexHtml(nfOptions) {
    return (content) => Promise.resolve((0, updateIndexHtml_1.updateScriptTags)(content, 'main.js', 'polyfills.js', nfOptions));
}
function addDebugInformation(fileName, rawBody) {
    if (fileName !== '/remoteEntry.json') {
        return rawBody;
    }
    const remoteEntry = JSON.parse(rawBody);
    const shared = remoteEntry.shared;
    if (!shared) {
        return rawBody;
    }
    const sharedForVite = shared.map((s) => (Object.assign(Object.assign({}, s), { packageName: `/@id/${s.packageName}` })));
    remoteEntry.shared = [...shared, ...sharedForVite];
    return JSON.stringify(remoteEntry, null, 2);
}
//# sourceMappingURL=builder.js.map